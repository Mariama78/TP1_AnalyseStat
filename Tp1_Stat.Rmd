---
title: "Travail Pratique 1"
author: "Equipe A"
date: "2025-02-10"
output: html_document
---

```{r, load-libraries, echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
library(skimr)
library(tidyverse)
library(corrplot)
library(ggplot2)
library(tidyr)
library(stringr)
library(dplyr)
library(readr)
```


### Plan de l'analyse

#### 1- Presentation des données

Ce dataset contient les métadonnées de plus de 700 000 films répertoriés dans l’ensemble de données TMDB. Il est mis à jour quotidiennement pour garantir la mise à jour de l’ensemble de données sur les films. Les points de données comprennent les acteurs, l’équipe, les mots-clés de l’intrigue, le budget, les revenus, les affiches, les dates de sortie, les langues, les sociétés de production, les pays, le nombre de votes TMDB et les moyennes des votes, les critiques, les recommandations.

**Description des variables**

- id : Identifiant unique pour chaque film.
- title : Titre du film.
- genres : Genres du film, combinés dans une seule chaîne de caractères (ex : Action-Comedy).
- original_language : Langue originale du film.
- overview : Résumé ou description du film.
- popularity : Score de popularité du film.
- production_companies : Compagnies de production associées au film, listées dans une chaîne de caractères.
- release_date : Date de sortie du film.
- budget : Budget du film en dollars.
- revenue : Revenu généré par le film en dollars.
- runtime : Durée du film en minutes.
- status : Statut du film (ex : Released).
- tagline : Slogan du film.
- vote_average : Moyenne des votes pour le film.
- vote_count : Nombre total de votes reçus par le film.
- credits : Principaux acteurs et membres de l'équipe du film.
- keywords : Mots-clés associés au film, listés dans une chaîne de caractères.
- poster_path : Chemin vers l'image de l'affiche du film.
- backdrop_path : Chemin vers l'image de fond du film.
- recommendations : Identifiants de films recommandés basés sur ce film, listés dans une chaîne de caractères.

#### Importation des données

```{r, load-data}
movies <- read.csv("data/movies.csv")
print(nrow(movies))
print( ncol(movies))
```

#### 2- Exploration des données

```{r}
# Statistique descriptive

skim(movies)
```

- Détection des valeurs manquantes

```{r}

sum(is.na(movies))

```

```{r}

# supprimons toutes les liqnes comportant des données manquantes

movies <- na.omit(movies)
nrow(movies)

```


```{r}

#Verifions les films qui sont sortis ou non

# Comptons le nombre de films par statut
status_counts <- movies %>%
  group_by(status) %>%
  summarise(count = n())

print(status_counts)

```

Nous allons supprimer tous les films qui ne sont pas encore sortis, pour eviter les biais dans la suite de nos analyses.

```{r}
movies_released<-movies%>%
  filter(status=="Released")
nrow(movies_released)
```

**Detection et Traitement de données aberrantes**

```{r}
# definissons une fonction qui nous permet de determiner les valeurs aberrantes

clean_outliers <- function(data, column_name, k = 1.5) {
  Q1 <- quantile(data[[column_name]], 0.25, na.rm = TRUE)
  Q3 <- quantile(data[[column_name]], 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower_bound <- Q1 - k * IQR
  upper_bound <- Q3 + k * IQR

  clean_data <- data %>% 
    filter(.[[column_name]] >= lower_bound & .[[column_name]] <= upper_bound)

  return(clean_data)
}

```


Appliquons cette fonction sur certaines de nos variables essentielles a notre analyse

```{r}
# en appliquant sur budget:

movies_released<- clean_outliers(movies_released, "budget") 
nrow(movies_released)

```

```{r}
# En appliquant sur revenu

movies_released <- clean_outliers(movies_released,"revenue")
nrow(movies_released)
```

```{r}
# En appliquant sur runtime

movies_released <- clean_outliers(movies_released,"runtime")
nrow(movies_released)
```

```{r}
# En appliquant sur popularity

movies_released <- clean_outliers(movies_released,"popularity")
nrow(movies_released)
```

```{r}
# En appliquant sur vote_count

movies_released <- clean_outliers(movies_released,"vote_count")
nrow(movies_released)
```

Supprimons aussi certaines colonnes comme: poster_path, backdrop_path et recommendations, qui ne nous sont pas utiles. 

```{r}
# Suppressions des colonnes spécifiées
movies_clean <- movies_released %>% 
  select(-poster_path, -backdrop_path, -recommendations)
head(movies_clean)
```




#### 3- Analyse descriptive


Distribution des films par :

- **Année de sortie**
```{r movie-year}
movies_clean$release_date <- as.Date(movies_clean$release_date, format="%Y-%m-%d")

movies_clean$release_year <- as.numeric(format(movies_clean$release_date, "%Y"))

ggplot(movies_clean, aes(x = release_year)) +
  geom_histogram(binwidth = 5, fill="steelblue", color="black") +
  labs(title="Distribution des films par année de sortie", x="Année", y="Nombre de films") +
  theme_minimal()

```

- **Genre**

```{r movie-genres}
data_genres <- movies_clean %>%
  filter(!is.na(genres)) %>%
  mutate(genres = str_replace_all(genres, " ", "")) %>%
  separate_rows(genres, sep = ",") %>%
  count(genres, sort = TRUE)

top_genres <- data_genres %>%
  slice_max(n, n = 15)

ggplot(top_genres, aes(x = reorder(genres, n), y = n, fill = genres)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  labs(
    title = "Top 15 des Genres de Films les Plus Fréquents",
    x = "Genre",
    y = "Nombre de Films"
  ) +
  theme_minimal() +
  theme(
    text = element_text(size = 14),
    axis.text.y = element_text(face = "bold"),
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

```

- Pays de production
- Budget
- Revenus

- Analyse des moyennes et médianes importantes

- **Durée des films**

Après une observation des durées de films, nous remarquons plusieurs choses intéressantes:
```{r runtime}
movies_clean %>% 
  filter(!is.na(runtime)) %>%
  arrange(desc(runtime)) %>%
  head(10) %>%
  select(title, runtime)
```

Nous remarquons deux films "troll" qui durent plus de 96 ans chacun, ainsi que des films expérimentaux comme "Logistics" qui dure 35 jours.
Pour l'analyse exploratoire, nous ne tiendrons donc pas compte de ces films.

```{r runtime-hist}
runtime_data = movies_clean %>% 
  filter(!is.na(runtime)) %>%
  filter(runtime < 240) # Limitons-nous à des films de moins de 4h

ggplot(runtime_data, aes(runtime)) +
  geom_bar()
```

L'histogramme de la durée des films de moins de 4h nous permet d'obtenir plusieurs informations :  
1. On observe une distinction entre les courts métrages (10 min en moyenne) et des longs métrages (1h30 en moyenne).  
2. Il existe beaucoup de films dont la durée est nulle: `r runtime_data %>% filter(runtime == 0) %>% count()` au total.  

#### 4- Analyse exploratoire avancée

**Corrélations entre variables :**

```{r corr-table}
movies_corr <- cor(runtime_data %>% select_if(is.numeric))

corrplot(movies_corr, type="upper", tl.col="black", tl.srt=45)
```

Nous observons une relativement forte corrélation entre le revenu des films et le nombre de votes. Cela peut s'expliquer par le fait que plus un film fait d'entrées, plus ses revenus sont élevés et plus de personnes peuvent le noter.  
Nous observons une faible corrélation positive entre le budget et le revenu, ainsi qu'entre le budget et le nombre de votes.  


#### 5- Visualisation des données


**Graphiques de distribution**  
- Histogrammes  
- Diagrammes de dispersion  
- Cartes thermiques de corrélation  


#### 6- Modélisation prédictive potentielle


- Prédiction de succès de films



